一条SQL语句在MySQL中是如何执行的？

1.连接器
负责跟客户端建立连接、获取权限、维持和管理连接
如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。
这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

可以通过show processlist; 命令查看连接

客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。
如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。
数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。
建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。
但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。
2.查询缓存
查询缓存往往弊大于利
查询缓存失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会清空。
查看是否开启缓存：show variables like 'query_cache_type';
查看缓存的命中次数:show status like 'qcache_hits';


好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，如：

mysql> select SQL_CACHE * from T where ID=10；
MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。

3.分析器
词法分析：select username from userinfo这条 SQL 就会把 select 和 from 解析为关键字，其他的为非关键字。

语法分析：1.生成语法树的过程。2.预处理器：判断你输入的这个 SQL 语句是否满足 MySQL 语法，语句不对，就会收到“You have an error in your SQL syntax”的错误提醒

预处理器:预处理器则会进一步去检查解析树是否合法，比如表名是否存在，语句中表的列是否存 在等等，在这一步MySQL会检验用户是否有表的操作权限。（？？？待确定）

4.优化器
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。优化成本主要考虑IO成本和CPU成本:

IO 成本：即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关。
CPU 成本：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。

优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。

5.执行器
开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误(在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。

请解释一下你理解的事务是什么？
首先给事务下定义
事务指的是多个操作，组成这多个操作的每一个操作单元要么全都成功，要么全都失败。这也是事务想要达成的目的。

事务四大特性
原子性：指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。
一致性：指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。
隔离性：指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
持久性：指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
并发产生的问题
脏读：**一个事务读到了另一个事务未提交的数据。**例如，账户 A 转帐给 B 500元，B 余额增加后但事务还没有提交，此时另一个事务读到的是 B 增加后的余额，这就发生了脏读。
不可重复读：**一个事务范围内多次查询返回了不同的数据值。**由于在多次查询之间，有其他事务修改了数据并进行了提交。
幻读：**一个事务中执行两次完全相同的查询时，第二次查询所返回的结果集跟第一个查询不相同。**注意此时是结果集查询不同，因为记录的增加或删除，导致两次相同条件获取的结果记录数不同。
事务隔离级别
要解决并发产生的问题，我们是通过设置事务隔离级别来解决。而具体设置为哪个级别是由性能和安全性共同决定的。而隔离级别有以下四种：

读未提交：最低的隔离级别，这个隔离级别下，前面提到的三种并发问题都有可能发生。
读已提交：就是只能读取到其他事务已经提交的数据。这个隔离级别可以解决脏读问题。
可重复读。可以保证整个事务过程中，对同数据的多次读取结果是相同的。这个级别可以解决脏读和不可重复读的问题。
串行化。这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别可以解决前面提到的所有并发问题。
事务的安全性、性能与隔离级别的关系
安全性：串行化 > 可重复读 > 读已提交 > 读未提交。

性能：串行化 < 可重复读 < 读已提交 < 读未提交。


参考：
1.MySQL实战45讲 -- 林晓斌
2.Java高级工程师训练营